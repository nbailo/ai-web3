from typing import Optional, List, Dict, Any
from datetime import datetime
from dataclasses import dataclass, field
from web3 import Web3
import time
from datatypes import QuoteRequest, ChainSnapshot
from makeragent.SmartChatBot import MakerConfig

# ============================================================================
# Configuration
# This is a dump of vibe code generated by cursor 
# I am in the process of understanding
# Help is appreciated! Thank you
# ============================================================================

# Price engine service URL
PRICE_ENGINE_URL = "http://localhost:5000"

# Web3 connection (will be initialized per chain)
web3_connections: Dict[int, Web3] = {}

# Aqua contract addresses (per chain)
AQUA_ADDRESSES: Dict[int, str] = {
    8453: "0x0000000000000000000000000000000000000000",  # Base mainnet (placeholder)
}

# Aqua ABI (simplified - would need full ABI in production)
AQUA_ABI = [
    {
        "inputs": [
            {"name": "maker", "type": "address"},
            {"name": "app", "type": "address"},
            {"name": "strategyHash", "type": "bytes32"},
            {"name": "token", "type": "address"}
        ],
        "name": "rawBalances",
        "outputs": [
            {"name": "balance", "type": "uint248"},
            {"name": "tokensCount", "type": "uint8"}
        ],
        "stateMutability": "view",
        "type": "function"
    }
]

# ERC20 ABI (for allowance checks)
ERC20_ABI = [
    {
        "inputs": [
            {"name": "owner", "type": "address"},
            {"name": "spender", "type": "address"}
        ],
        "name": "allowance",
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    }
]

########

@dataclass
class RawBalances:
    """Raw balance information from Aqua strategy"""
    balance: str  # uint248 in base units
    tokensCount: int  # uint8: 0 = inactive, 0xff (255) = DOCKED, else = ACTIVE


@dataclass
class AllowanceInfo:
    """Token allowance information"""
    token: str
    allowance: str  # uint256 in base units
    spender: str


@dataclass
class ExplainabilityPayload:
    """Optional explainability data for Maker Agent consumers."""
    description: str
    rationale: Optional[str] = None
    spreadApplied: Optional[str] = None
    ttlSec: Optional[int] = None
    strategySelectionReason: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON response"""
        return {
            'description': self.description,
            'rationale': self.rationale,
            'spreadApplied': self.spreadApplied,
            'ttlSec': self.ttlSec,
            'strategySelectionReason': self.strategySelectionReason,
            'metadata': self.metadata
        }

# ============================================================================
# Helper Functions (for fetching data from external sources)
# ============================================================================

def get_web3_connection(chain_id: int) -> Optional[Web3]:
    """Get or create Web3 connection for a chain"""
    if chain_id in web3_connections:
        return web3_connections[chain_id]
    
    # RPC URLs per chain (would be in config in production)
    rpc_urls = {
        8453: "https://mainnet.base.org",  # Base mainnet
        1: "https://eth.llamarpc.com",  # Ethereum mainnet
    }
    
    if chain_id not in rpc_urls:
        return None
    
    try:
        w3 = Web3(Web3.HTTPProvider(rpc_urls[chain_id]))
        web3_connections[chain_id] = w3
        return w3
    except Exception as e:
        print(f"Error connecting to chain {chain_id}: {e}")
        return None


def fetch_maker_config_from_db(maker: str) -> Optional[MakerConfig]:
    """
    Fetch maker config from database.
    In production, this would query a real database.
    For now, returns a mock config.
    """
    # TODO: Implement actual database query
    # This is a placeholder that returns a default config
    return MakerConfig(
        maker=maker,
        allowedPairs=[],
        maxTradeSize="1000000000000000000000",  # 1000 tokens (assuming 18 decimals)
        dailyCaps=None,
        ttlRanges={"minSec": 60, "maxSec": 3600},
        spreadPresets=[{"name": "default", "spreadBps": 50}],
        paused=False,
        strategyHashes=[]
    )



def fetch_chain_snapshot(
    chain_id: int,
    maker: str,
    strategy_hash: str,
    token_out: str
) -> Optional[ChainSnapshot]:
    """
    Fetch chain snapshot via web3 calls.
    Fetches rawBalances from Aqua contract and allowances from ERC20 contracts.
    """
    w3 = get_web3_connection(chain_id)
    if not w3:
        return None
    
    aqua_address = AQUA_ADDRESSES.get(chain_id)
    if not aqua_address:
        return None
    
    try:
        # Fetch rawBalances from Aqua contract
        aqua_contract = w3.eth.contract(address=aqua_address, abi=AQUA_ABI)
        
        # Call rawBalances
        # Note: In production, you'd need the executor address (app parameter)
        # For now, using a placeholder
        executor_address = "0x0000000000000000000000000000000000000000"
        
        try:
            result = aqua_contract.functions.rawBalances(
                maker,
                executor_address,
                bytes.fromhex(strategy_hash[2:]) if strategy_hash.startswith('0x') else bytes.fromhex(strategy_hash),
                token_out
            ).call()
            
            balance = str(result[0])
            tokens_count = result[1]
            
            # Determine strategy status
            if tokens_count == 0:
                strategy_status = "INACTIVE"
            elif tokens_count == 0xff:  # 255
                strategy_status = "DOCKED"
            else:
                strategy_status = "ACTIVE"
            
            raw_balances = {
                'balance': balance,
                'tokensCount': tokens_count
            }
        except Exception as e:
            print(f"Error fetching rawBalances: {e}")
            # Return inactive status if call fails
            raw_balances = {'balance': '0', 'tokensCount': 0}
            strategy_status = "INACTIVE"
        
        # Fetch allowance (maker â†’ Aqua for tokenOut)
        token_contract = w3.eth.contract(address=token_out, abi=ERC20_ABI)
        try:
            allowance = token_contract.functions.allowance(maker, aqua_address).call()
            allowances = [{
                'token': token_out,
                'allowance': str(allowance),
                'spender': aqua_address
            }]
        except Exception as e:
            print(f"Error fetching allowance: {e}")
            allowances = []
        
        return ChainSnapshot(
            chainId=chain_id,
            maker=maker,
            strategyHash=strategy_hash,
            rawBalances=raw_balances,
            allowances=allowances,
            strategyStatus=strategy_status
        )
    except Exception as e:
        print(f"Error fetching chain snapshot: {e}")
        return None





